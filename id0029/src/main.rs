// <p>Consider all integer combinations of $a^b$ for $2 \le a \le 5$ and $2 \le b \le 5$:
// $$\begin{array}{rrrr}
// 2^2=4, &amp;2^3=8, &amp;2^4=16, &amp;2^5=32\\
// 3^2=9, &amp;3^3=27, &amp;3^4=81, &amp;3^5=243\\
// 4^2=16, &amp;4^3=64, &amp;4^4=256, &amp;4^5=1024\\
// 5^2=25, &amp;5^3=125, &amp;5^4=625, &amp;5^5=3125
// \end{array}$$</p>
// <p>If they are then placed in numerical order, with any repeats removed, we get the following sequence of $15$ distinct terms:
// $$4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125.$$</p>
// <p>How many distinct terms are in the sequence generated by $a^b$ for $2 \le a \le 100$ and $2 \le b \le 100$?</p>

use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Eq)]
struct PrimeFactorized {
    factors: HashMap<usize, usize>,
}

impl PrimeFactorized {
    fn factorize(mut num: usize, primes: &[usize]) -> Self {
        let mut factors = HashMap::new();
        for &p in primes {
            while num % p == 0 {
                num /= p;
                *factors.entry(p).or_insert(0) += 1;
            }
        }
        Self { factors }
    }

    fn pow(&self, num: usize) -> Self {
        let mut factors = HashMap::new();
        for (&k, &v) in self.factors.iter() {
            factors.insert(k, num * v);
        }
        Self { factors }
    }
}

fn collect_primes_up_to_100() -> Vec<usize> {
    let mut is_prime = [true; 100];
    is_prime[0] = false;
    is_prime[1] = false;

    for p in 2..100 {
        if !is_prime[p] {
            continue;
        }
        for d in ((2 * p)..100).step_by(p) {
            is_prime[d] = false;
        }
    }

    is_prime
        .into_iter()
        .enumerate()
        .filter_map(|(i, v)| if v { Some(i) } else { None })
        .collect()
}

fn main() {
    const A_BOUND: usize = 100;
    const B_BOUND: usize = 100;
    let primes = collect_primes_up_to_100();
    let mut answer = Vec::new();
    for a in 2..=A_BOUND {
        let a_factorized = PrimeFactorized::factorize(a, &primes);
        for b in 2..=B_BOUND {
            let pow = a_factorized.pow(b);
            if !answer.contains(&pow) {
                answer.push(pow);
            }
        }
    }
    println!("{}", answer.len());
}
